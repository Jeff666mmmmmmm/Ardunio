#include <Arduino.h>
#include <RPC.h>

// ==============================

// Ardunio Info

// ==============================

// Communication
bool handshakeDone = false;
unsigned long lastPingTime = 0;
const unsigned long PING_INTERVAL = 500;
const unsigned long Imporntant_Ping_Delay = 2000;
unsigned long Last_Imporntant_Ping_Delay = 0;

enum CommState { C_IDLE,
                 C_WAITING_ACK,
                 C_SENDING_DATA };
CommState commState = C_IDLE;
unsigned long commTimer = 0;
unsigned long lastCommTime = 0;              // when we last saw any traffic (in or out)
const unsigned long COMM_ACK_TIMEOUT = 200;  // abort if no response

// Is script error paused
bool scriptErrorPaused = false;
String lastErrorReason = "";

// Is script delayed and waiting for input
bool scriptWait = false;

bool heatSinkFansRunning = false;
unsigned long lastFanChange = 0;

bool scriptWaitForCommunication = false;

// Last sending out of data in miliseconds
unsigned long lastDataSend = 0;

// Last Receive data in miliseconds
unsigned long lastDataReceive = 0;

// Min/Max step delay
const float minStepDelay = 2.5;
const int maxStepDelay = 8;

// Direct color indicators pins
const int goodLight = 51;
const int commLight = 52;
const int errorLight = 53;

// Motor steps per inch
const int ardunioMotorStepsPerInch = 127;

// Motor enable pin
const int ENABLE_PIN_MOTOR = 22;

// Fan enable pin
const int ENABLE_PIN_FAN = 47;

// Set head angle 0..359 degrees (PXX where XX=base36 width 2)
volatile int targetHeadAngleDeg = 0;

// ==============================

// X H-bridge pins
const int IN1X = 25;
const int IN2X = 27;
const int IN3X = 29;
const int IN4X = 31;

// PressureLeaver activated read at pos 0
const int PressureLever_ReadX = 35;

// X step delay live in milliseconds
int stepDelayX = 5;

// X last step recorded
int lastStepX = 0;

// X max step distance 36 inch
const int maxXStep = 4572;

// X Posiotion from 0
volatile int motorStepPositionX = 0;
volatile int motorStepCompleationX = 0;

volatile int motorUptimeX = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeX = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecX = 0;   // Store last time check

// ==============================

// Z H-bridge pins
const int IN1Z = 24;
const int IN2Z = 26;
const int IN3Z = 28;
const int IN4Z = 30;

// PressureLeaver activated read at pos 0
const int PressureLever_ReadZ = 34;

// Z step delay live in milliseconds
int stepDelayZ = 5;

// Z last step recorded
int lastStepZ = 0;

// Z max step distance 36 inch
const int maxZStep = 4572;

// Z Posiotion from 0
volatile int motorStepPositionZ = 0;
volatile int motorStepCompleationZ = 0;

volatile int motorUptimeZ = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeZ = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecZ = 0;   // Store last time check

// ==============================

// Stepper motor sequence for 4-step drive
const int steps[4][4] = {
  { 1, 0, 1, 0 },  // Step 1
  { 0, 1, 1, 0 },  // Step 2
  { 0, 1, 0, 1 },  // Step 3
  { 1, 0, 0, 1 }   // Step 4
};

// ==============================

// Data to run immediately
String commandNow = "";

unsigned long lastPayloadRequestTime = 0;
String lastPayloadRequested = "";  // avoid duplicate requests


// Save data from server to execute later in order

// Define the number of executable commands
const int numCommands = 12;

// Create an array of Strings to hold your commands
String commands[numCommands];

// Last executing info
int lastCompleateCommandStringExecution = 0;
int lastCompleateCommandExecution = 0;

// Next Executing Info
int currentCommandNumber = 1;
int currentCommandStringExecution = 00000;
int currentCommandExecution = 00;

// String to send out to cloud
String msgForAttemptSendOverSerial = "";
int lastMessageSentUniqueID = 0;

// ==============================

String decimalToBase36(unsigned long number, int minLength = 5) {
  const char* chars = "0123456789abcdefghijklmnopqrstuvwxyz";
  String result = "";

  if (number == 0) result = "0";
  else {
    while (number > 0) {
      result = chars[number % 36] + result;
      number /= 36;
    }
  }

  // Pad to desired length
  while (result.length() < minLength) {
    result = "0" + result;
  }

  return result;
}

unsigned long base36ToDecimal(String input) {
  input.toLowerCase();
  const char* chars = "0123456789abcdefghijklmnopqrstuvwxyz";
  unsigned long result = 0;

  for (int i = 0; i < input.length(); ++i) {
    char c = input.charAt(i);
    const char* pos = strchr(chars, c);

    if (pos == nullptr) {
      // Invalid character; handle it how you want (return 0, error code, etc.)
      return 0;
    }

    int value = pos - chars;
    result = result * 36 + value;
  }

  return result;
}

// Function to energize X stepper motor coils
bool stepMotorX(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  // Normalize target step to 0..3
  step = (step % 4 + 4) % 4;

  // Direction from last energized phase: +1 (forward), +3 (backward), 0 (hold), 2 (invalid skip)
  int direction = (step - lastStepX + 4) % 4;

  // Decide motion & bounds
  bool moved = false;
  if (direction == 1) {  // forward
    if (ignoreBounds || motorStepPositionX < maxXStep) {
      motorStepPositionX++;
      moved = true;
    } else {
      msgForAttemptSendOverSerial = "EMotor X OOB fwd pos=" + String(motorStepPositionX) + " max=" + String(maxXStep);
      lastErrorReason = "Step Motor X ordered out of bounds (forward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
  } else if (direction == 3) {  // backward
    if (ignoreBounds || motorStepPositionX > 0) {
      motorStepPositionX--;
      moved = true;
    } else {
      msgForAttemptSendOverSerial = "EMotor X OOB back pos=" + String(motorStepPositionX);
      lastErrorReason = "Step Motor X ordered out of bounds (backward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
  } else if (direction == 2) {
    // Skipping one phase is an electrical mismatch—reject it
    msgForAttemptSendOverSerial = "EMotor X invalid phase jump";
    lastErrorReason = "Invalid X phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLight, HIGH);
    return false;
  }
  // direction==0 means "re-energize same phase" → no movement, allowed

  // Energize coils
  digitalWrite(IN1X, steps[step][0]);
  digitalWrite(IN2X, steps[step][1]);
  digitalWrite(IN3X, steps[step][2]);
  digitalWrite(IN4X, steps[step][3]);

  // Update last phase and step counters
  lastStepX = step;
  if (moved) motorStepCompleationX++;

  return true;
}

bool stepMotorXForward(bool ignoreBounds) {
  int nextStep = (lastStepX + 1) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

bool stepMotorXBackward(bool ignoreBounds) {
  int nextStep = (lastStepX + 3) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

// Function to energize Z stepper motor coils
bool stepMotorZ(int step, bool ignoreBounds) {
  if (scriptErrorPaused) return false;

  // Normalize target step to 0..3
  step = (step % 4 + 4) % 4;

  // Direction from last energized phase
  int direction = (step - lastStepZ + 4) % 4;

  bool moved = false;
  if (direction == 1) {  // forward
    if (ignoreBounds || motorStepPositionZ < maxZStep) {
      motorStepPositionZ++;
      moved = true;
    } else {
      msgForAttemptSendOverSerial = "EMotor Z OOB fwd pos=" + String(motorStepPositionZ) + " max=" + String(maxZStep);
      lastErrorReason = "Step Motor Z ordered out of bounds (forward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
  } else if (direction == 3) {  // backward
    if (ignoreBounds || motorStepPositionZ > 0) {
      motorStepPositionZ--;
      moved = true;
    } else {
      msgForAttemptSendOverSerial = "EMotor Z OOB back pos=" + String(motorStepPositionZ);
      lastErrorReason = "Step Motor Z ordered out of bounds (backward)";
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
      return false;
    }
  } else if (direction == 2) {
    msgForAttemptSendOverSerial = "EMotor Z invalid phase jump";
    lastErrorReason = "Invalid Z phase sequence (jump by 2)";
    scriptErrorPaused = true;
    digitalWrite(errorLight, HIGH);
    return false;
  }
  // direction==0: hold phase

  // Energize coils
  digitalWrite(IN1Z, steps[step][0]);
  digitalWrite(IN2Z, steps[step][1]);
  digitalWrite(IN3Z, steps[step][2]);
  digitalWrite(IN4Z, steps[step][3]);

  // Update last phase and counters
  lastStepZ = step;
  if (moved) motorStepCompleationZ++;

  return true;
}

bool stepMotorZForward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 1) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

bool stepMotorZBackward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 3) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

// Hold Motors
void stepMotorsActivated(bool run) {

  unsigned long currentMillis = millis();  // Get the current time

  // Update uptime or downtime based on the motor state
  if (run) {
    digitalWrite(ENABLE_PIN_MOTOR, HIGH);
    digitalWrite(ENABLE_PIN_FAN, HIGH);
    motorUptimeX += currentMillis - lastMilisecX;  // Increment uptime
  } else {
    digitalWrite(ENABLE_PIN_MOTOR, LOW);
    digitalWrite(ENABLE_PIN_FAN, LOW);
    motorDowntimeX += currentMillis - lastMilisecX;  // Increment downtime
  }

  // Update lastMillis to the current time
  lastMilisecX = currentMillis;
}

// two-digit "ms" field: "XY" -> X.Y milliseconds (0.0..9.9)
static inline float parseTwoDigitMs(const String& s, int off = 0) {
  int d0 = s.charAt(off) - '0';
  int d1 = s.charAt(off + 1) - '0';
  if (d0 < 0 || d0 > 9 || d1 < 0 || d1 > 9) return 0.0f;
  return d0 + d1 * 0.1f;
}

// sign-pair '0'..'3' => (+/+),(-/+),(+/-),(-/-)
static inline void applySignPair(char sp, int& xs, int& zs) {
  switch (sp) {
    case '0': /* +/+ */ break;
    case '1': xs = -xs; break;  // (-/+)
    case '2': zs = -zs; break;  // (+/-)
    case '3':
      xs = -xs;
      zs = -zs;  // (-/-)
      break;
    default: /* invalid handled in caller */ break;
  }
}


// Set All Motor Positions to 0
void homeStepperMotorsPositions() {
  // Ensure motor is powered
  stepMotorsActivated(true);

  stepDelayZ = 5;  // reasonable speed
  motorStepPositionZ = 0;

  // Step Z forward until limit switch is triggered
  for (int i = 0; i < maxZStep; i++) {
    stepMotorZForward(true);
    delay(stepDelayZ);

    if (digitalRead(PressureLever_ReadZ) == HIGH) {
      motorStepPositionZ = 0;
      msgForAttemptSendOverSerial = "SHomed Z at step " + String(i);
      return;
    }
  }

  // Step back 1 inch
  for (int i = 0; i < ardunioMotorStepsPerInch; i++) {
    stepMotorZForward(true);
    delay(stepDelayZ);
  }

  // If we reach here, homing failed
  msgForAttemptSendOverSerial = "EFailed to home Z";
  lastErrorReason = "Home Motor Never Triggerd leaver for point 0";
  scriptErrorPaused = true;
  digitalWrite(errorLight, HIGH);
}

// Execute individual command
bool executeCommand(String givenString) {
  // Task of command
  char task = givenString[0];

  // Info for task to be executed, if any
  String taskInfo = givenString.substring(1);

  Serial.println(taskInfo);

  // Pause script due to error
  if (task == 'A') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);

    scriptErrorPaused = true;
    lastErrorReason = "Forced Into Error state by command";
    digitalWrite(errorLight, HIGH);
    return true;
  }

  // Unpause script due to error
  if (task == 'B') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);

    scriptErrorPaused = false;
    digitalWrite(errorLight, LOW);
    return true;
  }

  // Put script into wait mode
  if (task == 'C') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptWait = true;
    return true;
  }

  // Remove script from wait mode
  if (task == 'D') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptWait = false;
    return true;
  }

  // Step motor X forward
  if (task == 'E') return stepMotorXForward(false);
  // Step motor X backward
  if (task == 'F') return stepMotorXBackward(false);
  // Step motor Z forward
  if (task == 'G') return stepMotorZForward(false);
  // Step motor Z backward
  if (task == 'H') return stepMotorZBackward(false);

  // Step motor X by relative step count
  if (task == 'I') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorXForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorXBackward(false)) return false;
        steps++;
      }
      delay(tempdelay);
    }
    return true;
  }

  // Step motor Z by relative step count
  if (task == 'J') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorZForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorZBackward(false)) return false;
        steps++;
      }
      delay(tempdelay);
    }
    return true;
  }

  // Hold all motor positions with force
  if (task == 'K') {
    stepMotorsActivated(true);
    return true;
  }

  // Move motor X to specific step (LddXXXX where dd=ms, XXXX=base36 width 4)
  if (task == 'L') {
    if (taskInfo.length() < 6) {
      msgForAttemptSendOverSerial = "EL-short";
      return false;
    }
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    unsigned long posUL = base36ToDecimal(taskInfo.substring(2, 6));  // 4 chars, 0..1,679,615
    int StepPosition = (int)posUL;

    if (StepPosition >= 0 && StepPosition <= maxXStep) {
      while (motorStepPositionX != StepPosition) {
        if (motorStepPositionX < StepPosition) {
          if (!stepMotorXForward(false)) return false;
        } else {
          if (!stepMotorXBackward(false)) return false;
        }
        delay(tempdelay);
      }
      return true;
    } else {
      msgForAttemptSendOverSerial = "EMotor X OOB (" + String(StepPosition) + ") max (" + String(maxXStep) + ")";
      return false;
    }
  }

  // Move motor Z to specific step (MddXXXX where dd=ms, XXXX=base36 width 4)
  if (task == 'M') {
    if (taskInfo.length() < 6) {
      msgForAttemptSendOverSerial = "EM-short";
      return false;
    }
    float tempdelay = parseTwoDigitMs(taskInfo, 0);
    unsigned long posUL = base36ToDecimal(taskInfo.substring(2, 6));
    int StepPosition = (int)posUL;

    if (StepPosition >= 0 && StepPosition <= maxZStep) {
      while (motorStepPositionZ != StepPosition) {
        if (motorStepPositionZ < StepPosition) {
          if (!stepMotorZForward(false)) return false;
        } else {
          if (!stepMotorZBackward(false)) return false;
        }
        delay(tempdelay);
      }
      return true;
    } else {
      msgForAttemptSendOverSerial = "EMotor Z OOB (" + String(StepPosition) + ") max (" + String(maxZStep) + ")";
      return false;
    }
  }

  // Ping back to server
  if (task == 'N') {
    msgForAttemptSendOverSerial = "P(" + String(millis()) + ")";
    return true;
  }

  // Move X and Z motors simultaneously
  // Move X and Z motors simultaneously (compact)
  // O + [delay(2)] + [signPair(1)] + [x36(3)] + [z36(3)]  => taskInfo.len == 9
  if (task == 'O') {
    if (taskInfo.length() != 9) {
      msgForAttemptSendOverSerial = "EO-length " + String(taskInfo.length());
      digitalWrite(errorLight, HIGH);
      return false;
    }

    // Parse fields
    float baseDelay = parseTwoDigitMs(taskInfo, 0);  // 0.0..9.9 ms (will be >=0.2 from sender)
    char signPair = taskInfo.charAt(2);
    if (signPair < '0' || signPair > '3') {
      msgForAttemptSendOverSerial = "EO-sign";
      digitalWrite(errorLight, HIGH);
      return false;
    }

    unsigned long xMagUL = base36ToDecimal(taskInfo.substring(3, 6));  // 3 chars
    unsigned long zMagUL = base36ToDecimal(taskInfo.substring(6, 9));  // 3 chars
    if (xMagUL > 46655UL || zMagUL > 46655UL) {                        // 36^3 - 1
      msgForAttemptSendOverSerial = "EO-mag36";
      digitalWrite(errorLight, HIGH);
      return false;
    }

    int xSteps = (int)xMagUL;
    int zSteps = (int)zMagUL;
    applySignPair(signPair, xSteps, zSteps);

    // Compute per-axis step periods so both finish together
    int ax = abs(xSteps), az = abs(zSteps);
    int maxSteps = (ax > az) ? ax : az;

    float xDelay = (ax == 0) ? baseDelay : (baseDelay * (float)maxSteps / (float)ax);
    float zDelay = (az == 0) ? baseDelay : (baseDelay * (float)maxSteps / (float)az);

    // Parallel stepping (simple millis() scheduler)
    unsigned long nextX = millis();
    unsigned long nextZ = nextX;

    int remX = ax, remZ = az;
    int dirX = (xSteps >= 0) ? +1 : -1;
    int dirZ = (zSteps >= 0) ? +1 : -1;

    while (remX > 0 || remZ > 0) {
      unsigned long now = millis();

      if (remX > 0 && now >= nextX) {
        if (dirX > 0) {
          if (!stepMotorXForward(false)) return false;
        } else {
          if (!stepMotorXBackward(false)) return false;
        }
        remX--;
        nextX = now + (unsigned long)(xDelay);
      }

      if (remZ > 0 && now >= nextZ) {
        if (dirZ > 0) {
          if (!stepMotorZForward(false)) return false;
        } else {
          if (!stepMotorZBackward(false)) return false;
        }
        remZ--;
        nextZ = now + (unsigned long)(zDelay);
      }

      delay(1);  // simple pacing
    }

    return true;
  }

  // Rotate head
  if (task == 'P') {
    if (taskInfo.length() != 2) {
      msgForAttemptSendOverSerial = "EP-len";
      return false;
    }
    unsigned long angUL = base36ToDecimal(taskInfo);
    int angle = (int)(angUL % 360UL);
    targetHeadAngleDeg = angle;

    // TODO: drive your rotation stepper/encoder here.
    // For now we just acknowledge.
    // msgForAttemptSendOverSerial = "P(θ=" + String(angle) + ")"; // optional debug

    return true;
  }

  // Stubbed out ping responses for show
  if (task >= 'Q' && task <= 'Z') {
    msgForAttemptSendOverSerial = "P(" + String(millis()) + ")";
    return true;
  }

  // Unknown command fallback
  msgForAttemptSendOverSerial = "EUnknown command: " + String(task);
  digitalWrite(errorLight, HIGH);
  return false;
}


// Able to execute next command in a string of commands
String getNextSection(String input) {
  // Skip 5-char payload ID
  input = input.substring(5);

  int sectionIndex = 0;
  int start = 0;

  while (true) {
    int end = input.indexOf(';', start);

    if (sectionIndex == currentCommandExecution) {
      // If there's a ';', return [start, end)
      if (end != -1) return input.substring(start, end);
      // No more ';' — if there's remaining text, treat it as the last command
      if (start < input.length()) return input.substring(start);
      // Nothing left
      return "";
    }

    // Not our section yet; advance
    if (end == -1) return "";  // ran out of sections
    sectionIndex++;
    start = end + 1;
  }
}


// Send and execute next command or request next payload if needed
void runCommands() {
  if (scriptErrorPaused || scriptWait) return;

  // Current payload body
  String input = commands[currentCommandStringExecution];
  if (input.length() >= 5) {
    String nextCommand = getNextSection(input);

    if (nextCommand != "") {
      if (executeCommand(nextCommand)) {
        // Update live & telemetry indices
        lastCompleateCommandStringExecution = currentCommandStringExecution;
        lastCompleateCommandExecution = currentCommandExecution;
        currentCommandExecution++;
      } else {
        scriptErrorPaused = true;
        digitalWrite(errorLight, HIGH);
      }
      return;
    }

    // Payload finished: clear slot & advance to next payload number
    commands[currentCommandStringExecution] = "";
    currentCommandNumber += 1;

    // When advancing, wipe executed index so the cloud sees a fresh payload start
    currentCommandExecution = 0;
    lastCompleateCommandExecution = 0;
  }

  // Try to find the payload matching currentCommandNumber
  bool foundNext = false;
  for (int i = 0; i < numCommands; i++) {
    if (commands[i].length() < 5) continue;
    String p36 = commands[i].substring(0, 5);
    int pNum = (int)base36ToDecimal(p36);
    if (pNum == currentCommandNumber) {
      currentCommandStringExecution = i;
      currentCommandExecution = 0;
      lastCompleateCommandStringExecution = i;
      lastCompleateCommandExecution = 0;
      foundNext = true;
      break;
    }
  }

  // If not found locally, request THE next needed payload (not +1)
  if (!foundNext && msgForAttemptSendOverSerial == "") {
    String needId = decimalToBase36(currentCommandNumber, 5);  // <-- fixed
    String constructedRequest = "R" + needId;

    if (millis() - lastPayloadRequestTime > Imporntant_Ping_Delay) {
      if (constructedRequest != lastPayloadRequested) {
        lastPayloadRequested = constructedRequest;
      }
      msgForAttemptSendOverSerial = constructedRequest;
      lastPayloadRequestTime = millis();
    }
  }
}

// Send bulk data
void sendBulkData() {
  if (millis() > lastDataSend + PING_INTERVAL and millis() > Last_Imporntant_Ping_Delay + Imporntant_Ping_Delay) {
    // script error paused Boolean 1 true 0 false
    // script wait paused Boolean 1 true 0 false
    // X leaver triggerd Boolean 1 true 0 false
    // X steps from 0
    // X steps total
    // Z leaver triggerd Boolean 1 true 0 false
    // Z steps from 0
    // Z steps total
    // Motor enabled Boolean 1 true 0 false
    // Fan enabled Boolean 1 true 0 false
    // Last command executed 7 digits 5-2

    lastMessageSentUniqueID += 1;
    String payload = String(decimalToBase36(lastMessageSentUniqueID, 5)) + "D" + String(scriptErrorPaused) + ";" + String(scriptWait) + ";" + String(digitalRead(PressureLever_ReadX)) + ";" + motorStepPositionX + ";" + motorStepCompleationX + ";" + String(digitalRead(PressureLever_ReadZ)) + ";" + motorStepPositionZ + ";" + motorStepCompleationZ + ";" + String(digitalRead(ENABLE_PIN_MOTOR)) + ";" + String(digitalRead(ENABLE_PIN_FAN)) + ";" + String(decimalToBase36(lastCompleateCommandStringExecution, 5)) + String(decimalToBase36(lastCompleateCommandExecution, 2));
    Serial1.println(payload);

    lastDataSend = millis();
    lastCommTime = millis();
  }
}

// Send priority message
bool sendImporntantData() {

  if (msgForAttemptSendOverSerial != "") {

    Serial.println(msgForAttemptSendOverSerial);
    lastMessageSentUniqueID += 1;
    Serial1.println(String(decimalToBase36(lastMessageSentUniqueID, 5)) + "I" + msgForAttemptSendOverSerial + ";" + String(decimalToBase36(lastCompleateCommandStringExecution, 5)) + String(decimalToBase36(lastCompleateCommandExecution, 2)));
    msgForAttemptSendOverSerial = "";

    lastDataSend = millis();
    lastCommTime = millis();
    Last_Imporntant_Ping_Delay = millis();
    return true;
  }
  return false;
}

// Check outgoing and inbound messages
// Check outgoing and inbound messages
void checkCommunication() {
  // — 1) Read & respond to anything incoming (drain quickly)
  while (Serial1.available()) {
    String in = Serial1.readStringUntil('\n');
    in.trim();
    if (in.length() == 0) break;  // ignore empty lines

    lastCommTime = millis();  // we saw traffic

    if (in == "AAreadAA") {
      // echo ping, complete handshake
      Serial1.println("AAreadAA");
      handshakeDone = true;
      digitalWrite(commLight, LOW);
      scriptWaitForCommunication = false;
      // continue; do NOT return here—let the common logic run below
    } else if (in.startsWith("I")) {
      if (!executeCommand(in.substring(1))) {
        scriptErrorPaused = true;
        digitalWrite(errorLight, HIGH);
      }
    } else if (in.startsWith("S")) {
      String body = in.substring(1);

      // Expect first 5 chars = base36 payload ID
      if (body.length() < 6) {  // 5 id + ';' at least
        msgForAttemptSendOverSerial = "EStore-short";
      } else {
        String p36 = body.substring(0, 5);
        unsigned long pNumUL = base36ToDecimal(p36);
        int pNum = (int)pNumUL;

        // Find existing slot for same payload or an empty one
        int slot = -1;
        for (int i = 0; i < numCommands; i++) {
          if (commands[i].length() >= 5 && commands[i].substring(0, 5) == p36) {
            slot = i;
            break;  // exact match wins
          }
          if (slot == -1 && commands[i].length() == 0) slot = i;  // remember first empty
        }

        if (slot == -1) {
          msgForAttemptSendOverSerial = "ECommand storage full";
        } else {
          commands[slot] = body;

          // If this is the payload we’re waiting for, select it and RESET counters
          if (pNum == currentCommandNumber) {
            currentCommandStringExecution = slot;
            currentCommandExecution = 0;                 // start at first command
            lastCompleateCommandStringExecution = slot;  // for telemetry framing
            lastCompleateCommandExecution = 0;           // wipe executed index
          }
        }
      }
    }
    // else: ignore unknown frame types
  }

  // — 2) If not yet handshaken, keep pinging regardless of input presence
  if (!handshakeDone) {
    if (millis() - lastPingTime >= PING_INTERVAL) {
      Serial1.println("AAreadAA");
      lastPingTime = millis();
    }
    return;  // wait here until we get their “AAreadAA” reply
  }

  // — 3) If we *were* handshaken, but it’s been too quiet, force re-handshake
  if (millis() - lastCommTime >= PING_INTERVAL * 5) {
    handshakeDone = false;
    scriptWaitForCommunication = true;  // << add this so runCommands() pauses
    digitalWrite(commLight, HIGH);
    return;  // drop back into the “not handshaken” logic
  }

  // — 4) Once handshaken, send your data
  if (!sendImporntantData()) {
    sendBulkData();
  }
}


// Set up script
void setup() {

  // Set control X pins as outputs
  pinMode(IN1X, OUTPUT);
  pinMode(IN2X, OUTPUT);
  pinMode(IN3X, OUTPUT);
  pinMode(IN4X, OUTPUT);
  pinMode(PressureLever_ReadX, INPUT);

  // ==============================

  // Set control Z pins as outputs
  pinMode(IN1Z, OUTPUT);
  pinMode(IN2Z, OUTPUT);
  pinMode(IN3Z, OUTPUT);
  pinMode(IN4Z, OUTPUT);
  pinMode(PressureLever_ReadZ, INPUT);

  pinMode(ENABLE_PIN_MOTOR, OUTPUT);
  pinMode(ENABLE_PIN_FAN, OUTPUT);

  // ==============================

  // Initialize Serial1 (TX1/RX1) at 9600 baud for ardunio to ardunio communication
  Serial1.begin(9600);
  Serial.begin(9600);

  // Set light pins as outputs
  pinMode(goodLight, OUTPUT);
  pinMode(commLight, OUTPUT);
  pinMode(errorLight, OUTPUT);

  // Until comm connected error light is on
  digitalWrite(commLight, HIGH);
  scriptWaitForCommunication = true;

  // Find and home motor positions
  homeStepperMotorsPositions();
}

// Main ongoing script loop
void loop() {

  // process incoming packets & queued bulk updates
  checkCommunication();

  // Run commands if posible
  if (!scriptErrorPaused && !scriptWait && !scriptWaitForCommunication) {
    runCommands();
  }
}
