#include <Arduino.h>
#include <RPC.h>

// ==============================

// Ardunio Info

// ==============================

// Communication
bool handshakeDone = false;
unsigned long lastPingTime = 0;
const unsigned long PING_INTERVAL = 800;
const unsigned long Imporntant_Ping_Delay = 2500;
int Last_Imporntant_Ping_Delay = 0;

enum CommState { C_IDLE,
                 C_WAITING_ACK,
                 C_SENDING_DATA };
CommState commState = C_IDLE;
unsigned long commTimer = 0;
unsigned long lastCommTime = 0;              // when we last saw any traffic (in or out)
const unsigned long COMM_ACK_TIMEOUT = 200;  // abort if no response

// Is script error paused
bool scriptErrorPaused = false;

// Is script delayed and waiting for input
bool scriptWait = false;

bool heatSinkFansRunning = false;
unsigned long lastFanChange = 0;


// Last sending out of data in miliseconds
int lastDataSend = 0;

// Last Receive data in miliseconds
int lastDataReceive = 0;

// Min/Max step delay
const float minStepDelay = 2.5;
const int maxStepDelay = 8;

// Direct color indicators pins
const int goodLight = 51;
const int commLight = 52;
const int errorLight = 53;

// Motor enable pin
const int ENABLE_PIN_MOTOR = 22;

// Fan enable pin
const int ENABLE_PIN_FAN = 47;

// ==============================

// X H-bridge pins
const int IN1X = 25;
const int IN2X = 27;
const int IN3X = 29;
const int IN4X = 31;

// PressureLeaver activated read at pos 0
const int PressureLever_ReadX = 35;

// X step delay live in milliseconds
int stepDelayX = 5;

// X last step recorded
int lastStepX = 0;

// X max step distance
const int maxXStep = 100;

// X Posiotion from 0
volatile int motorStepPositionX = 0;
volatile int motorStepCompleationX = 0;

volatile int motorUptimeX = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeX = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecX = 0;   // Store last time check

// ==============================

// Z H-bridge pins
const int IN1Z = 24;
const int IN2Z = 26;
const int IN3Z = 28;
const int IN4Z = 30;

// PressureLeaver activated read at pos 0
const int PressureLever_ReadZ = 34;

// Z step delay live in milliseconds
int stepDelayZ = 5;

// Z last step recorded
int lastStepZ = 0;

// Z max step distance
const int maxZStep = 100;

// Z Posiotion from 0
volatile int motorStepPositionZ = 0;
volatile int motorStepCompleationZ = 0;

volatile int motorUptimeZ = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeZ = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecZ = 0;   // Store last time check

// ==============================

// Stepper motor sequence for 4-step drive
const int steps[4][4] = {
  { 1, 0, 1, 0 },  // Step 1
  { 0, 1, 1, 0 },  // Step 2
  { 0, 1, 0, 1 },  // Step 3
  { 1, 0, 0, 1 }   // Step 4
};

// ==============================

// Data to run immediately
String commandNow = "";

unsigned long lastPayloadRequestTime = 0;
String lastPayloadRequested = "";  // avoid duplicate requests


// Save data from server to execute later in order

// Define the number of executable commands
const int numCommands = 12;

// Create an array of Strings to hold your commands
String commands[numCommands];

// Last executing info
int lastCompleateCommandStringExecution = 0;
int lastCompleateCommandExecution = 0;

// Next Executing Info
int currentCommandNumber = 1;
int currentCommandStringExecution = 00000;
int currentCommandExecution = 00;

// String to send out to cloud
String msgForAttemptSendOverSerial = "SRunning";
int lastMessageSentUniqueID = 0;

// ==============================

String decimalToBase36(unsigned long number) {
  const char* chars = "0123456789abcdefghijklmnopqrstuvwxyz";
  String result = "";

  if (number == 0) return "00000";

  while (number > 0) {
    result = chars[number % 36] + result;
    number /= 36;
  }

  // Pad to 5 characters
  while (result.length() < 5) {
    result = "0" + result;
  }

  return result;
}

unsigned long base36ToDecimal(String input) {
  input.toLowerCase();
  const char* chars = "0123456789abcdefghijklmnopqrstuvwxyz";
  unsigned long result = 0;

  for (int i = 0; i < input.length(); ++i) {
    char c = input.charAt(i);
    const char* pos = strchr(chars, c);

    if (pos == nullptr) {
      // Invalid character; handle it how you want (return 0, error code, etc.)
      return 0;
    }

    int value = pos - chars;
    result = result * 36 + value;
  }

  return result;
}

// Function to energize X stepper motor coils
bool stepMotorX(int step, bool ignoreBounds) {

  if (scriptErrorPaused) {
    return false;
  }

  // Direction
  int direction = (step - lastStepX + 4) % 4;

  // Ensure it is within bounds and then update position
  if (direction == 1 && (motorStepPositionX + 1 <= maxXStep || ignoreBounds)) {
    motorStepPositionX++;
  } else if (direction == 3 && (0 > motorStepPositionX - 1 || ignoreBounds)) {
    motorStepPositionX--;
  } else {
    // Out of bounds
    return false;
  }

  // Move physical motor
  digitalWrite(IN1X, steps[step][0]);
  digitalWrite(IN2X, steps[step][1]);
  digitalWrite(IN3X, steps[step][2]);
  digitalWrite(IN4X, steps[step][3]);

  // Last X move
  lastStepX = step;
  // Add step move
  motorStepCompleationX++;

  // Correctly functioned
  return true;
}

bool stepMotorXForward(bool ignoreBounds) {
  int nextStep = (lastStepX + 1) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

bool stepMotorXBackward(bool ignoreBounds) {
  int nextStep = (lastStepX + 3) % 4;
  return stepMotorX(nextStep, ignoreBounds);
}

// Function to energize Z stepper motor coils
bool stepMotorZ(int step, bool ignoreBounds) {

  if (scriptErrorPaused) {
    return false;
  }

  // Direction
  int direction = (step - lastStepZ + 4) % 4;

  // Ensure it is within bounds and then update position
  if (direction == 1 && (motorStepPositionZ + 1 <= maxZStep || ignoreBounds)) {
    motorStepPositionZ++;
  } else if (direction == 3 && (0 > motorStepPositionZ - 1 || ignoreBounds)) {
    motorStepPositionZ--;
  } else {
    // Out of bounds
    return false;
  }

  // Move physical motor
  digitalWrite(IN1Z, steps[step][0]);
  digitalWrite(IN2Z, steps[step][1]);
  digitalWrite(IN3Z, steps[step][2]);
  digitalWrite(IN4Z, steps[step][3]);

  // Last Z move
  lastStepZ = step;
  // Add step move
  motorStepCompleationZ++;

  // Correctly functioned
  return true;
}

bool stepMotorZForward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 1) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

bool stepMotorZBackward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 3) % 4;
  return stepMotorZ(nextStep, ignoreBounds);
}

// Hold Motors
void stepMotorsActivated(bool run) {

  unsigned long currentMillis = millis();  // Get the current time

  // Update uptime or downtime based on the motor state
  if (run) {
    digitalWrite(ENABLE_PIN_MOTOR, HIGH);
    digitalWrite(ENABLE_PIN_FAN, HIGH);
    motorUptimeX += currentMillis - lastMilisecX;  // Increment uptime
  } else {
    digitalWrite(ENABLE_PIN_MOTOR, LOW);
    digitalWrite(ENABLE_PIN_FAN, LOW);
    motorDowntimeX += currentMillis - lastMilisecX;  // Increment downtime
  }

  // Update lastMillis to the current time
  lastMilisecX = currentMillis;
}

// Set All Motor Positions to 0
void homeStepperMotorsPositions() {
  // Ensure motor is powered
  stepMotorsActivated(true);

  stepDelayZ = 5; // reasonable speed
  motorStepPositionZ = 0;

  int maxSeekSteps = 6000;

  // Step Z forward until limit switch is triggered
  for (int i = 0; i < maxSeekSteps; i++) {
    stepMotorZForward(true);
    delay(stepDelayZ);

    if (digitalRead(PressureLever_ReadZ) == HIGH) {
      motorStepPositionZ = 0;
      msgForAttemptSendOverSerial = "SHomed Z at step " + String(i);
      return;
    }
  }

  // If we reach here, homing failed
  msgForAttemptSendOverSerial = "EFailed to home Z";
  scriptErrorPaused = true;
  digitalWrite(errorLight, HIGH);
}

// Execute individual command
bool executeCommand(String givenString) {
  // Task of command
  char task = givenString[0];

  // Info for task to be executed, if any
  String taskInfo = givenString.substring(1);

  // Pause script due to error
  if (task == 'A') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptErrorPaused = true;
    digitalWrite(errorLight, HIGH);
    return true;
  }

  // Unpause script due to error
  if (task == 'B') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptErrorPaused = false;
    digitalWrite(errorLight, LOW);
    return true;
  }

  // Put script into wait mode
  if (task == 'C') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptWait = true;
    return true;
  }

  // Remove script from wait mode
  if (task == 'D') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptWait = false;
    return true;
  }

  // Step motor X forward
  if (task == 'E') return stepMotorXForward(false);
  // Step motor X backward
  if (task == 'F') return stepMotorXBackward(false);
  // Step motor Z forward
  if (task == 'G') return stepMotorZForward(false);
  // Step motor Z backward
  if (task == 'H') return stepMotorZBackward(false);

  // Step motor X by relative step count
  if (task == 'I') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorXForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorXBackward(false)) return false;
        steps++;
      }
      delay(tempdelay);
    }
    return true;
  }

  // Step motor Z by relative step count
  if (task == 'J') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      if (steps > 0) {
        if (!stepMotorZForward(false)) return false;
        steps--;
      } else {
        if (!stepMotorZBackward(false)) return false;
        steps++;
      }
      delay(tempdelay);
    }
    return true;
  }

  // Hold all motor positions with force
  if (task == 'K') {
    stepMotorsActivated(true);
    return true;
  }

  // Move motor X to specific step
  if (task == 'L') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int StepPosition = atoi(taskInfo.substring(2).c_str());

    if (StepPosition >= 0 && StepPosition <= maxXStep) {
      while (motorStepPositionX != StepPosition) {
        if (motorStepPositionX < StepPosition) {
          if (!stepMotorXForward(false)) return false;
        } else {
          if (!stepMotorXBackward(false)) return false;
        }
        delay(tempdelay);
      }
      return true;
    } else {
      msgForAttemptSendOverSerial = "EMotor X OUT OF BOUNDS (" + String(StepPosition) + ") max (" + String(maxXStep) + ")";
      return false;
    }
  }

  // Move motor Z to specific step
  if (task == 'M') {
    float tempdelay = taskInfo.substring(0, 2).toFloat();
    int StepPosition = atoi(taskInfo.substring(2).c_str());

    if (StepPosition >= 0 && StepPosition <= maxZStep) {
      while (motorStepPositionZ != StepPosition) {
        if (motorStepPositionZ < StepPosition) {
          if (!stepMotorZForward(false)) return false;
        } else {
          if (!stepMotorZBackward(false)) return false;
        }
        delay(tempdelay);
      }
      return true;
    } else {
      msgForAttemptSendOverSerial = "EMotor Z OUT OF BOUNDS (" + String(StepPosition) + ") max (" + String(maxZStep) + ")";
      return false;
    }
  }

  // Ping back to server
  if (task == 'N') {
    msgForAttemptSendOverSerial = "P(" + String(millis()) + ")";
    return true;
  }

  // Move X and Z motors simultaneously
  if (task == 'O') {
    int half = taskInfo.length() / 2;
    String xSeg = taskInfo.substring(0, half);
    String zSeg = taskInfo.substring(half);

    float xDelay = xSeg.substring(0, 2).toFloat();
    int xSteps = xSeg.substring(2).toInt();

    float zDelay = zSeg.substring(0, 2).toFloat();
    int zSteps = zSeg.substring(2).toInt();

    unsigned long nextX = millis();
    unsigned long nextZ = nextX;
    int remX = abs(xSteps), remZ = abs(zSteps);
    int dirX = (xSteps >= 0 ? +1 : -1);
    int dirZ = (zSteps >= 0 ? +1 : -1);

    while (remX > 0 || remZ > 0) {
      unsigned long now = millis();

      if (remX > 0 && now >= nextX) {
        if (dirX > 0) stepMotorXForward(false);
        else stepMotorXBackward(false);
        remX--;
        nextX = now + (unsigned long)xDelay;
      }

      if (remZ > 0 && now >= nextZ) {
        if (dirZ > 0) stepMotorZForward(false);
        else stepMotorZBackward(false);
        remZ--;
        nextZ = now + (unsigned long)zDelay;
      }

      delay(1);
    }

    return true;
  }

  // Stubbed out ping responses for show
  if (task >= 'P' && task <= 'Z') {
    msgForAttemptSendOverSerial = "P(" + String(millis()) + ")";
    return true;
  }

  // Unknown command fallback
  msgForAttemptSendOverSerial = "EUnknown command: " + String(task);
  digitalWrite(errorLight, HIGH);
  return false;
}


// Able to execute next command in a string of commands
String getNextSection(String input) {
  // Always skip the first 5 characters (payload ID)
  input = input.substring(5);

  int sectionNumber = 0;
  int start = 0;
  int end = input.indexOf(';');

  while (end != -1) {
    if (sectionNumber == lastCompleateCommandExecution) {
      return input.substring(start, end);
    }
    sectionNumber++;
    start = end + 1;
    end = input.indexOf(';', start);
  }

  return "";
}

// Send and execute next command or request next payload if needed
void runCommands() {
  // Exit early if paused or waiting
  if (scriptErrorPaused || scriptWait) return;

  // Try to run next command in current payload
  String input = commands[currentCommandStringExecution];
  String nextCommand = getNextSection(input);

  if (nextCommand != "") {
    // Try to run it
    if (executeCommand(nextCommand)) {
      lastCompleateCommandStringExecution = currentCommandStringExecution;
      lastCompleateCommandExecution = currentCommandExecution;
      currentCommandExecution++;
    } else {
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
    }
    return;  // Done for this loop
  }

  // === Step 1: Clean up and see if any new payloads are waiting ===

  // Clear the finished payload (optional: only if fully consumed)
  commands[currentCommandStringExecution] = "";

  // Try to find the next command payload in sequence
  bool hasUnfinishedCommand = false;
  for (int i = 0; i < numCommands; i++) {
    if (commands[i].length() == 0) continue;

    int semicolonIndex = commands[i].indexOf(';');
    if (semicolonIndex == -1) continue;  // malformed

    String numberPart = commands[i].substring(0, semicolonIndex);
    int commandNum = numberPart.toInt();

    if (commandNum == currentCommandNumber + 1) {
      // Found next command string
      currentCommandStringExecution = i;
      currentCommandExecution = 0;
      currentCommandNumber += 1;
      hasUnfinishedCommand = true;
      break;
    }
  }

  // === Step 2: If no more payloads are present, and nothing else is pending, request next ===

  if (!hasUnfinishedCommand && msgForAttemptSendOverSerial == "") {
    String nextPayloadID = decimalToBase36(currentCommandNumber + 1);
    String constructedRequest = "R" + nextPayloadID + "00" +
                                 String(lastCompleateCommandStringExecution) +
                                 String(lastCompleateCommandExecution);

    // Only request if 3s passed or request changed
    if (millis() - lastPayloadRequestTime > 3000 || constructedRequest != lastPayloadRequested) {
      msgForAttemptSendOverSerial = constructedRequest;
      lastPayloadRequestTime = millis();
      lastPayloadRequested = constructedRequest;
    }
  }
}

// Send bulk data
void sendData() {
  if (millis() > lastDataSend + PING_INTERVAL and millis() > Last_Imporntant_Ping_Delay + Imporntant_Ping_Delay) {
    // script error paused Boolean 1 true 0 false
    // script wait paused Boolean 1 true 0 false
    // X leaver triggerd Boolean 1 true 0 false
    // X steps from 0
    // X steps total
    // Z leaver triggerd Boolean 1 true 0 false
    // Z steps from 0
    // Z steps total
    // Motor enabled Boolean 1 true 0 false
    // Fan enabled Boolean 1 true 0 false
    // Last command executed 7 digits 5-2

    lastMessageSentUniqueID += 1;
    String payload = String(decimalToBase36(lastMessageSentUniqueID)) + "D" + String(scriptErrorPaused) + ";" + String(scriptWait) + ";" + String(digitalRead(PressureLever_ReadX)) + ";" + motorStepPositionX + ";" + motorStepCompleationX + ";" + String(digitalRead(PressureLever_ReadZ)) + ";" + motorStepPositionZ + ";" + motorStepCompleationZ + ";" + String(digitalRead(ENABLE_PIN_MOTOR)) + ";" + String(digitalRead(ENABLE_PIN_FAN)) + ";" + lastCompleateCommandStringExecution + lastCompleateCommandExecution;
    Serial1.println(payload);

    lastDataSend = millis();
    lastCommTime = millis();
  }
}

void sendImporntantData() {

  if (msgForAttemptSendOverSerial) {
    lastMessageSentUniqueID += 1;
    Serial1.println(String(decimalToBase36(lastMessageSentUniqueID)) + "I" + msgForAttemptSendOverSerial + ";" + lastCompleateCommandStringExecution + lastCompleateCommandExecution);
    msgForAttemptSendOverSerial = "";

    lastDataSend = millis();
    lastCommTime = millis();
    Last_Imporntant_Ping_Delay = millis();
  }
}

void checkCommunication() {
  // — 1) Read & respond to anything incoming
  if (Serial1.available()) {
    String in = Serial1.readStringUntil('\n');
    in.trim();
    lastCommTime = millis();  // mark that we saw traffic

    if (in == "AAreadAA") {
      // always echo a ping, even if already handshaken
      Serial1.println("AAreadAA");
      handshakeDone = true;
      digitalWrite(commLight, LOW);
    } else {
      // real data frame—handle it here
      if (in.startsWith("I")) {
        if (!executeCommand(in.substring(1))) {
          scriptErrorPaused = true;
          digitalWrite(errorLight, HIGH);
        }
      }
      // Save data to run in order
      else if (in.startsWith("S")) {
        // your “store command” logic…
        String body = in.substring(1);
        bool stored = false;
        for (int i = 0; i < numCommands; i++) {
          if (commands[i].length() == 0) {
            commands[i] = body;
            stored = true;
            break;
          }
        }
        if (!stored) {
          msgForAttemptSendOverSerial = "ECommand storage full";
        }
      }
      // …any other incoming types…
    }
  }

  // — 2) If not yet handshaken, keep pinging
  if (!handshakeDone) {
    if (millis() - lastPingTime >= PING_INTERVAL) {
      Serial1.println("AAreadAA");
      lastPingTime = millis();
    }
    return;  // wait here until we get their “AAreadAA” reply
  }

  // — 3) If we *were* handshaken, but it’s been too quiet, force re-handshake
  if (millis() - lastCommTime >= PING_INTERVAL * 5) {
    handshakeDone = false;
    digitalWrite(commLight, HIGH);
    return;  // drop back into the “not handshaken” logic
  }

  // — 4) Once handshaken, send your periodic bulk data
  sendData();
}

// Set up script
void setup() {

  // Set control X pins as outputs
  pinMode(IN1X, OUTPUT);
  pinMode(IN2X, OUTPUT);
  pinMode(IN3X, OUTPUT);
  pinMode(IN4X, OUTPUT);
  pinMode(PressureLever_ReadX, INPUT);

  // ==============================

  // Set control Z pins as outputs
  pinMode(IN1Z, OUTPUT);
  pinMode(IN2Z, OUTPUT);
  pinMode(IN3Z, OUTPUT);
  pinMode(IN4Z, OUTPUT);
  pinMode(PressureLever_ReadZ, INPUT);

  pinMode(ENABLE_PIN_MOTOR, OUTPUT);
  pinMode(ENABLE_PIN_FAN, OUTPUT);

  // ==============================

  // Initialize Serial1 (TX1/RX1) at 9600 baud for ardunio to ardunio communication
  Serial1.begin(9600);
  Serial.begin(9600);

  // Set light pins as outputs
  pinMode(goodLight, OUTPUT);
  pinMode(commLight, OUTPUT);
  pinMode(errorLight, OUTPUT);

  // Until comm connected error light is on
  digitalWrite(commLight, HIGH);

  // Find and home motor positions
  homeStepperMotorsPositions();
}


void loop() {

  // process incoming packets & queued bulk updates
  checkCommunication();

  // Run commands if posible
  if (!scriptErrorPaused && !scriptWait) {
    runCommands();
  }
}
