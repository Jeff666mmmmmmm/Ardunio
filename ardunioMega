#include <Arduino.h>
#include <RPC.h>

// ==============================

// Ardunio Info

// ==============================

// Communication
const int commLedPin = 3;
bool handshakeDone = false;
unsigned long lastPingTime = 0;
const unsigned long PING_INTERVAL = 2000;  // ms

enum CommState { C_IDLE,
                 C_WAITING_ACK,
                 C_SENDING_DATA };
CommState commState = C_IDLE;
unsigned long commTimer = 0;
unsigned long lastCommTime    = 0;       // when we last saw any traffic (in or out)
const unsigned long COMM_ACK_TIMEOUT = 200;  // abort if no response

// Is script error paused
bool scriptErrorPaused = false;

// Is script delayed and waiting for input
bool scriptWait = false;

bool heatSinkFansRunning = false;
unsigned long lastFanChange = 0;


// Last sending out of data in miliseconds
int lastDataSend = 0;

// Last Receive data in miliseconds
int lastDataReceive = 0;

// Min/Max step delay
const float minStepDelay = 2.5;
const int maxStepDelay = 8;

// Direct color indicators pins
const int goodLight = 51;
const int commLight = 52;
const int errorLight = 53;

// ==============================

// X H-bridge pins
const int IN1X = 25;
const int IN2X = 27;
const int IN3X = 29;
const int IN4X = 31;

// X motor enable pin
const int ENABLE_PINX = 23;

// PressureLeaver activated read at pos 0
const int PressureLever_ReadX = 35;

// X step delay live in milliseconds
int stepDelayX = 5;

// X last step recorded
int lastStepX = 0;

// X max step distance
const int maxXStep = 100;

// X Posiotion from 0
volatile int motorStepPositionX = 0;
volatile int motorStepCompleationX = 0;

volatile int motorUptimeX = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeX = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecX = 0;   // Store last time check

// ==============================

// Z H-bridge pins
const int IN1Z = 24;
const int IN2Z = 26;
const int IN3Z = 28;
const int IN4Z = 30;

// Z motor enable pin
const int ENABLE_PINZ = 22;

// PressureLeaver activated read at pos 0
const int PressureLever_ReadZ = 34;

// Z step delay live in milliseconds
int stepDelayZ = 5;

// Z last step recorded
int lastStepZ = 0;

// Z max step distance
const int maxZStep = 100;

// Z Posiotion from 0
volatile int motorStepPositionZ = 0;
volatile int motorStepCompleationZ = 0;

volatile int motorUptimeZ = 0;    // Time the motor is running (milliseconds)
volatile int motorDowntimeZ = 0;  // Time the motor is stopped (milliseconds)
unsigned long lastMilisecZ = 0;   // Store last time check

// ==============================

// Stepper motor sequence for 4-step drive
const int steps[4][4] = {
  { 1, 0, 1, 0 },  // Step 1
  { 0, 1, 1, 0 },  // Step 2
  { 0, 1, 0, 1 },  // Step 3
  { 1, 0, 0, 1 }   // Step 4
};

// ==============================

// Data to run immediately
String commandNow = "";

// Save data from server to execute later in order

// Define the number of executable commands
const int numCommands = 12;

// Create an array of Strings to hold your commands
String commands[numCommands];

// Last executing info
int lastCompleateCommandStringExecution = -1;
int lastCompleateCommandExecution = -1;

// Next Executing Info
int currentCommandNumber = 1;
int currentCommandStringExecution = 00000;
int currentCommandExecution = 00;

// String to send out to cloud
String msgForAttemptSendOverSerial = "Running";

// ==============================

String decimalToBase36(unsigned long number) {
  const char* chars = "0123456789abcdefghijklmnopqrstuvwxyz";
  String result = "";

  if (number == 0) return "00000";

  while (number > 0) {
    result = chars[number % 36] + result;
    number /= 36;
  }

  // Pad to 5 characters
  while (result.length() < 5) {
    result = "0" + result;
  }

  return result;
}

unsigned long base36ToDecimal(String input) {
  input.toLowerCase();
  const char* chars = "0123456789abcdefghijklmnopqrstuvwxyz";
  unsigned long result = 0;

  for (int i = 0; i < input.length(); ++i) {
    char c = input.charAt(i);
    const char* pos = strchr(chars, c);

    if (pos == nullptr) {
      // Invalid character; handle it how you want (return 0, error code, etc.)
      return 0;
    }

    int value = pos - chars;
    result = result * 36 + value;
  }

  return result;
}

// Function to energize X stepper motor coils
bool stepMotorX(int step, bool ignoreBounds) {

  if (scriptErrorPaused) {
    return false;
  }

  // Direction
  int direction = (step - lastStepX + 4) % 4;

  // Ensure it is within bounds and then update position
  if (direction == 1 && (motorStepPositionX + 1 <= maxXStep || ignoreBounds)) {
    motorStepPositionX++;
  } else if (direction == 3 && (0 > motorStepPositionX - 1 || ignoreBounds)) {
    motorStepPositionX--;
  } else {
    // Out of bounds
    return false;
  }

  // Move physical motor
  digitalWrite(ENABLE_PINX, HIGH);
  digitalWrite(IN1X, steps[step][0]);
  digitalWrite(IN2X, steps[step][1]);
  digitalWrite(IN3X, steps[step][2]);
  digitalWrite(IN4X, steps[step][3]);
  digitalWrite(ENABLE_PINX, LOW);

  // Last X move
  lastStepX = step;
  // Add step move
  motorStepCompleationX++;

  // Correctly functioned
  return true;
}

void stepMotorXForward(bool ignoreBounds) {
  int nextStep = (lastStepX + 1) % 4;
  stepMotorX(nextStep, ignoreBounds);
}

void stepMotorXBackward(bool ignoreBounds) {
  int nextStep = (lastStepX + 3) % 4;
  stepMotorX(nextStep, ignoreBounds);
}

// Function to energize Z stepper motor coils
bool stepMotorZ(int step, bool ignoreBounds) {

  if (scriptErrorPaused) {
    return false;
  }

  // Direction
  int direction = (step - lastStepZ + 4) % 4;

  // Ensure it is within bounds and then update position
  if (direction == 1 && (motorStepPositionZ + 1 <= maxZStep || ignoreBounds)) {
    motorStepPositionZ++;
  } else if (direction == 3 && (0 > motorStepPositionZ - 1 || ignoreBounds)) {
    motorStepPositionZ--;
  } else {
    // Out of bounds
    return false;
  }

  // Move physical motor
  digitalWrite(ENABLE_PINZ, HIGH);
  digitalWrite(IN1Z, steps[step][0]);
  digitalWrite(IN2Z, steps[step][1]);
  digitalWrite(IN3Z, steps[step][2]);
  digitalWrite(IN4Z, steps[step][3]);
  digitalWrite(ENABLE_PINZ, LOW);

  // Last Z move
  lastStepZ = step;
  // Add step move
  motorStepCompleationZ++;

  // Correctly functioned
  return true;
}

void stepMotorZForward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 1) % 4;
  stepMotorZ(nextStep, ignoreBounds);
}

void stepMotorZBackward(bool ignoreBounds) {
  int nextStep = (lastStepZ + 3) % 4;
  stepMotorZ(nextStep, ignoreBounds);
}

// Hold X motor
void stepMotorXHold(bool run) {
  unsigned long currentMillis = millis();  // Get the current time

  // Update uptime or downtime based on the motor state
  if (run) {
    motorUptimeX += currentMillis - lastMilisecX;  // Increment uptime
    digitalWrite(ENABLE_PINX, HIGH);               // Turn motor on
  } else {
    motorDowntimeX += currentMillis - lastMilisecX;  // Increment downtime
    digitalWrite(ENABLE_PINX, LOW);                  // Turn motor off
  }

  // Update lastMillis to the current time
  lastMilisecX = currentMillis;
}

// Hold Z motor
void stepMotorZHold(bool run) {
  unsigned long currentMillis = millis();  // Get the current time

  // Update uptime or downtime based on the motor state
  if (run) {
    motorUptimeZ += currentMillis - lastMilisecZ;  // Increment uptime
    digitalWrite(ENABLE_PINZ, HIGH);               // Turn motor on
  } else {
    motorDowntimeZ += currentMillis - lastMilisecZ;  // Increment downtime
    digitalWrite(ENABLE_PINZ, LOW);                  // Turn motor off
  }

  // Update lastMillis to the current time
  lastMilisecZ = currentMillis;
}

// Hold motor positions with force
void holdMotorPositions() {
  stepMotorXHold(true);
  stepMotorZHold(true);
}

// Set All Motor Positions to 0
void homeStepperMotorsPositions() {

  // Motor Z Homing Routine
  stepDelayZ = 4.5;
  int motorHomeCompleationZ = 0;
  int stepsToLeverZ = 0;
  int stepsFromLeverZ = 0;
  int stepsReturnLeverZ = 0;

  // Step to until lever is hit (HIGH)
  for (int i = 0; i < 5000; i++) {
    stepMotorZForward(true);
    delay(stepDelayZ);

    // Is motor touched switch
    if (digitalRead(PressureLever_ReadZ) == HIGH) {
      motorHomeCompleationZ += 1;
      stepsToLeverZ = i;
      stepDelayZ = 6;

      // Step until lever is released (LOW)
      delay(500);
      for (int j = 1500; j > 0; j--) {
        stepMotorZBackward(true);
        delay(stepDelayZ);

        // Is motor backed away from switch
        if (digitalRead(PressureLever_ReadZ) == LOW) {
          motorHomeCompleationZ += 1;
          stepsFromLeverZ = j;

          // Step to until lever is hit again (HIGH)
          delay(500);
          for (int k = 0; k < 1500; k++) {
            stepMotorZForward(true);
            delay(stepDelayZ);

            // Is motor back onto the switch
            if (digitalRead(PressureLever_ReadZ) == HIGH) {
              motorHomeCompleationZ += 1;
              stepsReturnLeverZ = k;
              motorStepPositionZ = 0;
              break;
            }
          }
          break;
        }
      }
      break;
    }
  }

  lastStepZ = 0;

  // Check if motor home worked
  if (motorHomeCompleationZ != 3) {

    msgForAttemptSendOverSerial = "ERROR HomMotor Z(" + String(stepsToLeverZ) + "/" + String(stepsFromLeverZ) + "/" + String(stepsFromLeverZ) + ")";
    scriptErrorPaused = true;
    digitalWrite(errorLight, HIGH);
  } else {
    msgForAttemptSendOverSerial = "Success HomMotor Z(" + String(stepsToLeverZ) + "/" + String(stepsFromLeverZ) + "/" + String(stepsFromLeverZ) + ")";
  }
}

// Execute indviual command
bool executeCommand(String givenString) {

  // Task of command
  char task = givenString[0];

  // info for task to be executed, if any
  String taskInfo = givenString.substring(1);

  // pause script due to error
  if (task == 'A') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptErrorPaused = true;
    digitalWrite(errorLight, HIGH);
    return true;
  }
  // unpasue script due to error
  if (task == 'B') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptErrorPaused = false;
    digitalWrite(errorLight, LOW);
    return true;
  }
  // put script into wait mode
  if (task == 'C') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptWait = true;
    return true;
  }
  // remove script from wait mode
  if (task == 'D') {
    digitalWrite(goodLight, HIGH);
    delay(200);
    digitalWrite(goodLight, LOW);
    scriptWait = false;
    return true;
  }
  // step motor x forward
  if (task == 'E') {
    stepMotorXForward(false);
    return true;
  }
  // step motor x backward
  if (task == 'F') {
    stepMotorXBackward(false);
    return true;
  }
  // step motor z forward
  if (task == 'G') {
    stepMotorZForward(false);
    return true;
  }
  // step motor z backward
  if (task == 'H') {
    stepMotorZBackward(false);
    return true;
  }
  // step motor x for steps unknown
  if (task == 'I') {

    // Get varibles for loop
    float tempdelay = (taskInfo[0] - '0') + (taskInfo[1] - '0') * 0.1;
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      // move steps number one step toward zero
      steps += (steps > 0 ? -1 : +1);

      if (steps >= 0) {
        stepMotorXForward(false);
      } else {
        stepMotorXBackward(false);
      }

      delay(tempdelay);
    }
    return true;
  }
  // step motor z for steps unknown
  if (task == 'J') {
    // Get varibles for loop
    float tempdelay = (taskInfo[0] - '0') + (taskInfo[1] - '0') * 0.1;
    int steps = atoi(taskInfo.substring(2).c_str());

    while (steps != 0) {
      // move steps number one step toward zero
      steps += (steps > 0 ? -1 : +1);

      if (steps >= 0) {
        stepMotorZForward(false);
      } else {
        stepMotorZBackward(false);
      }

      delay(tempdelay);
    }
    return true;
  }
  // hold all motor positions with force
  if (task == 'K') {
    holdMotorPositions();
    return true;
  }
  // Move motor X to specific step
  if (task == 'L') {
    // Get varibles for loop
    float tempdelay = (taskInfo[0] - '0') + (taskInfo[1] - '0') * 0.1;
    int StepPosition = atoi(taskInfo.substring(2).c_str());

    if (StepPosition > 0 && StepPosition <= maxXStep) {

      // When motor not at end step
      while (motorStepPositionX != StepPosition) {

        // Move motor closer to end step
        if (motorStepPositionX >= 0) {
          stepMotorXForward(false);
        } else {
          stepMotorXBackward(false);
        }

        delay(tempdelay);
      }
      return true;

    } else {
      msgForAttemptSendOverSerial = "ERROR motor X OUT OF BOUNDS (" + String(StepPosition) + ") max (" + String(maxXStep) + ")";
      return false;
    }
  }
  // Move motor Z to specific step
  if (task == 'M') {
    // Get varibles for loop
    float tempdelay = (taskInfo[0] - '0') + (taskInfo[1] - '0') * 0.1;
    int StepPosition = atoi(taskInfo.substring(2).c_str());

    if (StepPosition > 0 && StepPosition <= maxZStep) {

      // When motor not at end step
      while (motorStepPositionZ != StepPosition) {

        // Move motor closer to end step
        if (motorStepPositionZ >= 0) {
          stepMotorZForward(false);
        } else {
          stepMotorZBackward(false);
        }

        delay(tempdelay);
      }
      return true;

    } else {
      msgForAttemptSendOverSerial = "ERROR motor Z OUT OF BOUNDS (" + String(StepPosition) + ") max (" + String(maxZStep) + ")";
      return false;
    }
  }
  // Ping back to server
  if (task == 'N') {
    msgForAttemptSendOverSerial = "Ping (" + String(millis()) + ")";
    return true;
  }
  // move X and Z motor
  if (task == 'O') {
    // --- assume taskInfo is exactly two back-to-back segments ---
    int len = taskInfo.length();
    int half = len / 2;

    // split in two equal parts
    String xSeg = taskInfo.substring(0, half);
    String zSeg = taskInfo.substring(half);

    // parse X
    float xDelay = (xSeg[0] - '0') + (xSeg[1] - '0') * 0.1f;
    int xSteps = xSeg.substring(2).toInt();

    // parse Z
    float zDelay = (zSeg[0] - '0') + (zSeg[1] - '0') * 0.1f;
    int zSteps = zSeg.substring(2).toInt();

    // “parallel” blocking loop
    unsigned long nextX = millis();
    unsigned long nextZ = nextX;
    int remX = abs(xSteps), remZ = abs(zSteps);
    int dirX = (xSteps >= 0 ? +1 : -1);
    int dirZ = (zSteps >= 0 ? +1 : -1);

    while (remX > 0 || remZ > 0) {
      unsigned long now = millis();

      if (remX > 0 && now >= nextX) {
        if (dirX > 0) stepMotorXForward(false);
        else stepMotorXBackward(false);
        remX--;
        nextX = now + (unsigned long)xDelay;
      }

      if (remZ > 0 && now >= nextZ) {
        if (dirZ > 0) stepMotorZForward(false);
        else stepMotorZBackward(false);
        remZ--;
        nextZ = now + (unsigned long)zDelay;
      }

      delay(1);
    }

    return true;
  }
  // Rotate Y motor
  if (task == 'P') {
    // fill in later
    return true;
  }
  // Move up and down Y motor
  if (task == 'Q') {
   
    return true;
  }
    // Move up and down Y motor
  if (task == 'R') {
    
    return true;
  }
  if (task == 'S') {
    msgForAttemptSendOverSerial = "Ping (" + String(millis()) + ")";
    return true;
  }
  if (task == 'T') {
    msgForAttemptSendOverSerial = "Ping (" + String(millis()) + ")";
    return true;
  }
  if (task == 'U') {
    msgForAttemptSendOverSerial = "Ping (" + String(millis()) + ")";
    return true;
  }
  if (task == 'W') {
    msgForAttemptSendOverSerial = "Ping (" + String(millis()) + ")";
    return true;
  }
  if (task == 'X') {
    msgForAttemptSendOverSerial = "Ping (" + String(millis()) + ")";
    return true;
  }
  if (task == 'Y') {
    msgForAttemptSendOverSerial = "Ping (" + String(millis()) + ")";
    return true;
  }
  if (task == 'Z') {
    msgForAttemptSendOverSerial = "Ping (" + String(millis()) + ")";
    return true;
  }
}

// Able to execute next command in a string of commands
String getNextSection(String input) {
  int sectionNumber = 1;
  int start = 0;
  int end = input.indexOf(';');

  while (end != -1) {
    if (sectionNumber == lastCompleateCommandExecution + 1) {
      return input.substring(start, end);
    }
    sectionNumber++;
    start = end + 1;
    end = input.indexOf(';', start);
  }

  return "";
}

// Execute saved commands
void runCommands() {

  String input = commands[currentCommandStringExecution];
  String nextCommand = getNextSection(input);

  // If next command in string
  if (nextCommand) {
    // Run command, if succcess continue
    if (executeCommand(nextCommand) == true) {
      lastCompleateCommandStringExecution = currentCommandStringExecution;
      lastCompleateCommandExecution = currentCommandExecution;
      currentCommandExecution += 1;
    } else {
      scriptErrorPaused = true;
      digitalWrite(errorLight, HIGH);
    }
  } else {

    // Clear last string we compleated and executed
    commands[currentCommandStringExecution - 1] = "";
    for (int i = 0; i < numCommands; i++) {
      if (commands[i].length() == 0) continue;  // Skip empty strings

      int semicolonIndex = commands[i].indexOf(';');
      if (semicolonIndex == -1) continue;  // Skip malformed strings

      String numberPart = commands[i].substring(0, semicolonIndex);
      int commandNum = numberPart.toInt();

      // New data found, set up for execution
      if (commandNum == currentCommandNumber + 1) {

        currentCommandStringExecution = i;
        currentCommandExecution = 0;
        currentCommandNumber += 1;
      }
    }
  }
}

// Send bulk data
void sendData() {
  if (millis() > lastDataSend + PING_INTERVAL) {
    // script error paused Boolean 1 true 0 false
    // script wait paused Boolean 1 true 0 false
    // X leaver triggerd Boolean 1 true 0 false
    // X steps from 0
    // X steps total
    // Z leaver triggerd Boolean 1 true 0 false
    // Z steps from 0
    // Z steps total
    // Last command executed 7 digits 5-2
    volatile int motorStepPositionZ = 0;
volatile int motorStepCompleationZ = 0;
    String payload = "D" + String(scriptErrorPaused) + ";" + String(scriptWait) + ";" + String(digitalRead(PressureLever_ReadX)) + ";" + motorStepPositionX + ";" + motorStepCompleationX + ";" + String(digitalRead(PressureLever_ReadZ)) + ";" + motorStepPositionZ + ";" + motorStepCompleationZ + ";" + lastCompleateCommandStringExecution + lastCompleateCommandExecution;
    Serial1.println(payload);

    lastDataSend   = millis();
    lastCommTime   = millis();
  }
}

void checkCommunication() {
  // — 1) Read & respond to anything incoming
  if (Serial1.available()) {
    String in = Serial1.readStringUntil('\n');
    in.trim();
    lastCommTime = millis();      // mark that we saw traffic

    if (in == "AAreadAA") {
      // always echo a ping, even if already handshaken
      Serial1.println("AAreadAA");
      handshakeDone = true;
      digitalWrite(commLight, LOW);
    }
    else {
      // real data frame—handle it here
      if (in.startsWith("I")) {
        if (!executeCommand(in.substring(1))) {
          scriptErrorPaused = true;
          digitalWrite(errorLight, HIGH);
        }
      }
      // Save data to run in order
      else if (in.startsWith("S")) {
        // your “store command” logic…
        String body = in.substring(1);
        bool stored = false;
        for (int i = 0; i < numCommands; i++) {
          if (commands[i].length() == 0) {
            commands[i] = body;
            stored = true;
            break;
          }
        }
        if (!stored) {
          msgForAttemptSendOverSerial = "ERROR command storage full";
        }
      }
      // …any other incoming types…
    }
  }

  // — 2) If not yet handshaken, keep pinging
  if (!handshakeDone) {
    if (millis() - lastPingTime >= PING_INTERVAL) {
      Serial1.println("AAreadAA");
      lastPingTime = millis();
    }
    return;  // wait here until we get their “AAreadAA” reply
  }

  // — 3) If we *were* handshaken, but it’s been too quiet, force re-handshake
  if (millis() - lastCommTime >= PING_INTERVAL * 5) {
    handshakeDone    = false;
    digitalWrite(commLight, HIGH);
    return;  // drop back into the “not handshaken” logic
  }

  // — 4) Once handshaken, send your periodic bulk data
  sendData();
}

// Set up script
void setup() {

  // Set control X pins as outputs
  pinMode(IN1X, OUTPUT);
  pinMode(IN2X, OUTPUT);
  pinMode(IN3X, OUTPUT);
  pinMode(IN4X, OUTPUT);
  pinMode(ENABLE_PINX, OUTPUT);
  pinMode(PressureLever_ReadX, INPUT);

  // ==============================

  // Set control Z pins as outputs
  pinMode(IN1Z, OUTPUT);
  pinMode(IN2Z, OUTPUT);
  pinMode(IN3Z, OUTPUT);
  pinMode(IN4Z, OUTPUT);
  pinMode(ENABLE_PINZ, OUTPUT);
  pinMode(PressureLever_ReadZ, INPUT);

  // ==============================

  // Initialize Serial1 (TX1/RX1) at 9600 baud for ardunio to ardunio communication
  Serial1.begin(9600);

  // Set light pins as outputs
  pinMode(goodLight, OUTPUT);
  pinMode(commLight, OUTPUT);
  pinMode(errorLight, OUTPUT);

  // Until comm connected error light is on
  digitalWrite(commLight, HIGH);

  // Find and home motor positions
  homeStepperMotorsPositions();
}


void loop() {

  // process incoming packets & queued bulk updates
  checkCommunication();

  // Run commands if posible
  if (!scriptErrorPaused && !scriptWait) {
    runCommands();
  }
}
